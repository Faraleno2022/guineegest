# Generated by Django 5.2.6 on 2025-09-25 15:21

from django.db import migrations


def backfill_entreprise(apps, schema_editor):
    # Fetch models using historical version from apps
    Vehicule = apps.get_model('fleet_app', 'Vehicule')
    FournisseurVehicule = apps.get_model('fleet_app', 'FournisseurVehicule')
    LocationVehicule = apps.get_model('fleet_app', 'LocationVehicule')
    FeuillePontageLocation = apps.get_model('fleet_app', 'FeuillePontageLocation')
    FactureLocation = apps.get_model('fleet_app', 'FactureLocation')
    User = apps.get_model('auth', 'User')
    Profil = apps.get_model('fleet_app', 'Profil')
    Entreprise = apps.get_model('fleet_app', 'Entreprise')

    # Build a mapping: user_id -> entreprise_id
    user_to_ent = {}

    # Prefer user.profil.entreprise if exists
    for profil in Profil.objects.all():
        if profil.user_id:
            ent_id = None
            try:
                ent = profil.entreprise
                ent_id = getattr(ent, 'id', None)
            except Exception:
                ent_id = None
            if ent_id:
                user_to_ent[profil.user_id] = ent_id

    # Fallback: user has direct entreprise attribute (if present historically)
    # We cannot reliably access user.entreprise in historical models; skip unless present in mapping

    def assign_ent_for_queryset(qs):
        # Iterate in chunks to avoid loading everything in memory
        BATCH = 500
        last_pk = 0
        model = qs.model
        pk_name = model._meta.pk.name
        # Simple batching by primary key
        while True:
            batch = list(qs.filter(**{f"{pk_name}__gt": last_pk}).order_by(pk_name)[:BATCH])
            if not batch:
                break
            updates = []
            for obj in batch:
                if getattr(obj, 'entreprise_id', None):
                    continue
                user_id = getattr(obj, 'user_id', None)
                ent_id = user_to_ent.get(user_id)
                if ent_id:
                    setattr(obj, 'entreprise_id', ent_id)
                    updates.append(obj)
            if updates:
                model.objects.bulk_update(updates, ['entreprise'])
            last_pk = getattr(batch[-1], pk_name)

    assign_ent_for_queryset(Vehicule.objects.all())
    assign_ent_for_queryset(FournisseurVehicule.objects.all())
    assign_ent_for_queryset(LocationVehicule.objects.all())
    assign_ent_for_queryset(FeuillePontageLocation.objects.all())
    assign_ent_for_queryset(FactureLocation.objects.all())


def noop_reverse(apps, schema_editor):
    # No-op reverse; we won't unset entreprises
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('fleet_app', '0013_facturelocation_entreprise_and_more'),
    ]

    operations = [
        migrations.RunPython(backfill_entreprise, noop_reverse),
    ]
